import json
import mock
import pytest

import ckan.tests.factories as factories
import ckan.model as model
import ckan.plugins.toolkit as tk

from ckanext.hdx_org_group.helpers.static_lists import ORGANIZATION_TYPE_LIST
from ckanext.hdx_package.actions.get import _get_resource_hdx_relative_url

_get_action = tk.get_action
ValidationError = tk.ValidationError

hdx_relative_resulted_urls = []


def _get_resource_hdx_relative_url_wrapped(*args, **kwargs):
    result = _get_resource_hdx_relative_url(*args, **kwargs)
    hdx_relative_resulted_urls.append(result)
    return result


SYSADMIN_USER = 'some_sysadmin_user'
DATASET_NAME = 'dataset_name_for_hdx_rel_url'
LOCATION_NAME = 'some_location_for_hdx_rel_url'
ORG_NAME = 'org_name_for_hdx_rel_url'
DATASET_DICT = {
    "package_creator": "test function",
    "private": False,
    "dataset_date": "[1960-01-01 TO 2012-12-31]",
    "caveats": "These are the caveats",
    "license_other": "TEST OTHER LICENSE",
    "methodology": "This is a test methodology",
    "dataset_source": "Test data",
    "license_id": "hdx-other",
    "name": DATASET_NAME,
    "notes": "This is a test dataset",
    "title": "Test Dataset " + DATASET_NAME,
    "owner_org": ORG_NAME,
    "groups": [{"name": LOCATION_NAME}],
    "data_update_frequency": "30",
    "maintainer": SYSADMIN_USER
}

RESOURCE_LINKED_URL = 'http://test.ckan.net/hxlproxy/api/data-preview.csv?url=https%3A%2F%2Ftest.test%2Ftest%2Ftest.csv'


@pytest.fixture()
def setup_data():
    factories.User(name=SYSADMIN_USER, email='some_user@hdx.hdxtest.org', sysadmin=True)
    group = factories.Group(name=LOCATION_NAME)
    factories.Organization(
        name=ORG_NAME,
        title='ORG NAME FOR HDX_REL_URL',
        users=[
            {'name': SYSADMIN_USER, 'capacity': 'editor'},
        ],
        hdx_org_type=ORGANIZATION_TYPE_LIST[0][1],
        org_url='https://hdx.hdxtest.org/'
    )

    context = {'model': model, 'session': model.Session, 'user': SYSADMIN_USER}
    dataset_dict = _get_action('package_create')(context, DATASET_DICT)


@pytest.mark.usefixtures("keep_db_tables_on_clean", "clean_db", "clean_index", "setup_data")
class TestHdxRelUrl(object):
    def _create_uploaded_resource(self, context):
        resource = {
            'url': 'hdx_test.csv',
            'url_type': 'upload',
            'resource_type': 'file.upload',
            'format': 'CSV',
            'name': 'hdx_test1.csv',
            'package_id': DATASET_NAME,
        }
        try:
            resource_dict = _get_action('resource_create')(context, resource)
        except ValidationError as e:
            assert False
        return resource_dict

    def _create_linked_resource(self, context):
        resource = {
            'package_id': DATASET_NAME,
            'url': RESOURCE_LINKED_URL,
            'resource_type': 'api',
            'url_type': 'api',
            'format': 'CSV',
            'name': 'test.csv'
        }
        try:
            resource_dict = _get_action('resource_create')(context, resource)
        except ValidationError as e:
            assert False
        return resource_dict

    @mock.patch('ckanext.hdx_package.actions.get._get_resource_hdx_relative_url',
                wraps=_get_resource_hdx_relative_url_wrapped)
    def test_hdx_rel_url(self, hdx_rel_url_patch):
        '''
        We're testing that all URLs that are generated by _get_resource_hdx_relative_url() will actually be
        absolute or relative URLs.
        '''
        context = {'model': model, 'session': model.Session, 'user': SYSADMIN_USER}
        resource_dict1 = self._create_uploaded_resource(context)
        assert not self._simple_filename_in_url_list()

        resource_dict1_modified = _get_action('resource_patch')(context, {
            'id': resource_dict1['id'],
            'description': 'Modified description',
        })
        assert not self._simple_filename_in_url_list()

        data_revise_dict = {
            "match": {"id": resource_dict1['package_id']},
            "filter": [
                "+resources__" + resource_dict1['id'] + "__id",
                "-resources__" + resource_dict1['id'] + "__*"
            ],
            "update__resources__" + resource_dict1['id']: resource_dict1_modified
        }
        assert not self._simple_filename_in_url_list()

        _get_action('package_revise')(context, data_revise_dict)
        assert not self._simple_filename_in_url_list()

        _get_action('package_show')({'use_cache': False, 'for_edit': True}, {'id': DATASET_NAME})
        assert not self._simple_filename_in_url_list()

    def test_hdx_rel_url_not_changing_for_linked_resources(self):
        context = {'model': model, 'session': model.Session, 'user': SYSADMIN_USER}
        resource_dict1 = self._create_linked_resource(context)
        assert resource_dict1.get('hdx_rel_url') == RESOURCE_LINKED_URL, \
            'hdx_rel_url shouldn\'t change for linked resources'

    def _simple_filename_in_url_list(self):
        '''
        If there's no slash in one of the entries, it means that one is not a URL.
        That entry is just a filename.
        '''
        result = False
        for url_item in hdx_relative_resulted_urls:
            if '/' not in url_item:
                result = True
                break
        hdx_relative_resulted_urls.clear()
        return result
